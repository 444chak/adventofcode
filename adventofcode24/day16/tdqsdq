import os
import time
import heapq

start = time.time()
path = os.path.dirname(os.path.realpath(__file__))
file = path + "/data.txt"
with open(file, encoding="utf-8") as f:
    data = []
    data = f.read().splitlines()

reindeer = [
    (i, j) for i, line in enumerate(data) for j, char in enumerate(line) if char == "S"
][0]

end = [
    (i, j) for i, line in enumerate(data) for j, char in enumerate(line) if char == "E"
][0]

# walls = {
#     (i, j) for i, line in enumerate(data) for j, char in enumerate(line) if char == "#"
# }

grid = [list(line) for line in data]

dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

r_dir = (0, 1)

# move is 1 point, and rotate is 1000 points, find the path with the least points


def dijkstra(start, end, grid, r_dir):
    q = [
        (0, start[0], start[1], r_dir[0], r_dir[1], {(start[0], start[1])})
    ]  # cost, x, y, dx, dy, path
    seen = set()
    while len(q) > 0:
        d, x, y, dx, dy, path = heapq.heappop(q)
        if (x, y) in seen:
            continue
        seen.add((x, y))

        if (x, y) == end:
            return d, path

        for ddx, ddy in dirs:
            if ddx == -dx and ddy == -dy:
                continue
            nx, ny = x + ddx, y + ddy
            is_straight = abs(ddx) == abs(dx) and abs(ddy) == abs(dy)
            cost = 1
            if not is_straight:
                cost += 1000

            if grid[ny][nx] == "#" or (nx, ny) in seen:
                continue

            new_path = path.copy()
            new_path.add((nx, ny))
            heapq.heappush(q, (d + cost, nx, ny, ddx, ddy, new_path))

    return None, None


for dir in dirs:
    print(dijkstra(reindeer, end, grid, dir)[0])

print("Time taken: " + str(round(time.time() - start, 3)) + "s")

# 94350 < x < 95444
